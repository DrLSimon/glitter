<div style="margin-top:-20px">
<h3>Part 1: the <tt>git</tt> revision control system</h3>
<div class="text-justify">
<p>
	The base code of CGI is provided as a <tt>git</tt> repository. <tt>git</tt>
	is the most widespread distributed version control system in use today—it is a good
	idea to familiarize yourself with this system if you've never used it before.
        As the semester progresses, we will push out a number of additions to
        the CGI framework. You can simply <tt>merge</tt> our new revisions
        into your repository to benefit from these improvements.
</p>
<p>
Recommended learning resources for git are:
<a href="https://try.github.io/levels/1/challenges/1">try git</a>,
<a href="http://rogerdudler.github.io/git-guide/">git-the simple guide</a>,
the <a href="http://gitimmersion.com/index.html">git immersion tutorial</a>, and
the extensive free <a href="http://git-scm.com/book/en/v2">Pro Git</a> ebook.
The remainder of this section describes the steps needed to clone and compile the CGI base code.
</p>
</div>
<div class="col-md-6 text-justify">
	<h3>Cloning using the command line</h3>
	<p>
		The source code of CGI is available on <a
		href="https://github.com/DrLsimon/CGI">github</a>.
		To check out a copy of the source code, enter
	</p>
<pre class="prettyprint lang-bash">
$ git clone --recursive --single-branch  https://github.com/DrLSimon/CGI</pre>
  <p>
  on the terminal. The <tt>--recursive</tt> flags ensures
  that all dependency libraries are cloned as well. The
  <tt>--single-branch</tt> prevents from fetching the <tt>gh-pages</tt> branch.	
  </p>
</div>

<div class="col-md-6 text-justify">
	<h3>Updating the codebase</h3>
  <p>
  We'll likely publish extensions and bug-fixes to this
  repository as the semester progresses. To get them, 
  navigate into the <tt>CGI</tt> directory and run the command
  <pre class="prettyprint lang-bash">
$ git pull</pre>
  If there were any concurrent modifications to the same file,
  <tt>git</tt> may ask you to resolve merge conflicts. We refer you to
  the learning resources for information about resolving conflicts in
  general.
  </p>
</div>
<div class="row col-md-12">
    <div class="alert alert-danger" role="alert"><b>Note</b>: Since your
        repository will contain homework solutions it is (obviously) not OK to
        post it online (in particular, don't fork the <tt>CGI</tt> project on
        github or elsewhere). Private forks (i.e. without public access) are
        allowed, however.
	</div>
</div>

<div class="row col-md-12">
<h3>Part 2: Setting up a C++ compiler and building the base code</h3>
<div class="row">
	<div class="col-md-6">
		<h3>Configuring on Linux / Mac OS X</h3>
		<p>
		Begin by installing the
		<a href="http://www.cmake.org/download/">CMake</a> build system on your
		system. On Mac OS X, you will also need to install a reasonably
		up-to-date version of XCode along with the command line tools.
		On Linux, any reasonably recent version of GCC or Clang will work.
		Navigate to the CGI folder, create a build directory and start <tt>cmake</tt>, like so:
		</p>
		<pre class="prettyprint lang-bash">
$ cd path-to-CGI
$ mkdir build
$ cd build
$ cmake .. -DCMAKE_BUILD_TYPE=Release</pre>
  </div>
	<div class="col-md-6">
		<h3>Building on Linux / Mac OS X</h3>
		After the Makefiles are generated, simply run
		<tt>make</tt> to compile all dependencies and CGI itself.
		<pre class="prettyprint lang-bash">
$ make -j 4</pre>
		This can take quite a while; the above command compiles with four
		processors at the same time. Note that you will probably see many
		warning messages while the dependencies are compiled—you can ignore
		them.
	</div>
</div>

</div>

<div class="row col-md-12">
<h3>Part 4: A high-level overview</h3>
The CGI repository consists of the base code files (left table)
and several dependency libraries (right table) that are briefly explained below.
</div>
<div class="row">
	<div class="col-md-6">
		<table class="table table-condensed">
			<thead> <tr> <th>Directory</th> <th>Description</th> </tr> </thead>
			<tbody>
				<tr><td><tt>src</tt></td><td>A directory containing the main C++ source code</td></tr>
				<tr><td><tt>include/nori</tt></td><td>A directory containing header files with declarations</td></tr>
				<tr><td><tt>ext</tt></td><td>External dependency libraries (see the table right)</td></tr>
				<tr><td><tt>scenes</tt></td><td>Example scenes and test datasets to validate your implementation</td></tr>
				<tr><td><tt>CMakeLists.txt</tt></td><td>A CMake build file which specifies how to compile and link CGI</td></tr>
			</tbody>
		</table>
	</div>
	<div class="col-md-6">
		<table class="table table-condensed">
			<thead> <tr> <th>Directory</th> <th>Description</th> </tr> </thead>
			<tbody>
				<tr><td><tt>ext/openexr</tt></td><td>A high dynamic range image format library</td></tr>
				<tr><td><tt>ext/pcg32</tt></td><td>A tiny self-contained pseudorandom number generator</td></tr>
				<tr><td><tt>ext/filesystem</tt></td><td>A tiny self-contained library for manipulating paths on various platforms</td></tr>
				<tr><td><tt>ext/pugixml</tt></td><td>A light-weight XML parsing library</td></tr>
				<tr><td><tt>ext/tbb</tt></td><td>Intel's Boost Thread Building Blocks for multi-threading</td></tr>
				<tr><td><tt>ext/tinyformat</tt></td><td>Type-safe C++11 version of <tt>printf</tt> and <tt>sprintf</tt></td></tr>
				<tr><td><tt>ext/hypothesis</tt></td><td>Functions for statistical hypothesis tests</td></tr>
				<tr><td><tt>ext/nanogui</tt></td><td>A minimalistic GUI library for OpenGL</td></tr>
				<tr><td><tt>ext/nanogui/ext/eigen</tt></td><td>A linear algebra library used by <tt>nanogui</tt> and Nori.</td></tr>
				<tr><td><tt>ext/zlib</tt></td><td>A compression library used by OpenEXR</td></tr>
			</tbody>
		</table>
	</div>
</div>
<div class="row col-md-12">
	Let's begin with a brief overview of the most important dependencies:
</div>
<div class="row">
	<div class="col-md-6 text-justify">
		<h4>Eigen</h4>
		<p>
			When developing any kind of graphics-related software, it's
			important to be familiar with the core mathematics support library
			that is responsible for basic linear algebra types, such as vectors,
			points, normals, and linear transformations. Nori uses
			<a href="http://eigen.tuxfamily.org">Eigen 3</a> for this
			purpose. We don't expect you to understand the inner workings of
			this library but recommend that you at least take a look at the
			helpful <a href="http://eigen.tuxfamily.org/dox">tutorial</a> 
			provided on the Eigen web page.

			<p>
				Nori provides a set of linear algebra types that are
				derived from Eigen's matrix/vector class (see e.g. the header file 
				<tt>include/nori/vector.h</tt>). This is necessary
				because we will be handling various quantities that
				require different treatment when undergoing homogeneous
				coordinate transformations, and in particular we must
				distinguish between positions, vectors, and normals.

				The main subset of types that you will most likely use are:
				<ul>
					<li><tt>Point2i</tt>,</li>
					<li><tt>Point2f</tt>,</li>
					<li><tt>Point3f</tt>,</li>
					<li><tt>Vector2i</tt>,</li>
					<li><tt>Vector2f</tt>,</li>
					<li><tt>Vector3f</tt>, and</li>
					<li><tt>Normal3f</tt>.</li>
				</ul>
				where the number indicates the dimension and the
				subsequent character denotes the underlying scalar
				type (i.e. integer or single precision floating point).
			</p>
		</p>
	</div>
</div>
<div class="row">
	<div class="col-md-12 text-justify">
		<h3>Scene file format and parsing</h3>
		<p>
			Take a moment to browse through the header files in
			<tt>include/nori</tt>. You will generally find all important
			interfaces and their documentation in this place. Most headers
			files also have a corresponding <tt>.cpp</tt> implementation file
			in the <tt>src</tt> directory.

			The most important class is called <tt>NoriObject</tt>—it is
			the base class of everything that can be constructed using the XML
			scene description language. Other interfaces (e.g. <tt>Camera</tt>)
			derive from this class and expose additional more specific
			functionality (e.g. to generate an outgoing ray from a camera).
		</p>

		<p>
			Nori uses a very simple XML-based scene description language, which
			can be interpreted as a kind of building plan: the parser creates
			the scene step by step as it reads the scene file from top to
			bottom. The XML tags in this document are interpreted as requests
			to construct certain C++ objects including information on how to
			put them together.
		</p>
		<p>
			Each XML tag is either an <em>object</em> or a <em>property</em>. Objects
			correspond to C++ instances that will be allocated on the heap. Properties are
			small bits of information that are passed to an object at the time of its
			instantiation.

			For instance, the following snippet creates red diffuse BSDF:
		</p>
		<pre class="prettyprint linenums lang-xml">
&lt;bsdf type="diffuse"&gt;
    &lt;color name="albedo" value="0.5, 0, 0"/&gt;
&lt;/bsdf&gt;</pre>
		<p>
			Here, the <tt>&lt;bsdf&gt;</tt> tag will cause the
			creation of an object of type <tt>BSDF</tt>, and the
			<tt>type</tt> attribute specifies what specific subclass
			of <tt>BSDF</tt> should be used.
			The <tt>&lt;color&gt;</tt> tag creates a property of name <tt>albedo</tt>
			that will be passed to its constructor.
			If you open up the C++ source file <tt>src/diffuse.cpp</tt>, you will see that 
			there is a constructor, which looks for 
			<span rel="tooltip" title="Or alternatively substitutes 50% grey when no value is provided.">this specific property</span>:
		</p>
		<pre class="prettyprint linenums">
Diffuse(const PropertyList &amp;propList) {
    m_albedo = propList.getColor("albedo", Color3f(0.5f));
}</pre>
		<p>
			The piece of code that associates the
			<tt>"diffuse"</tt> XML identifier with the <tt>Diffuse</tt>
			class in the C++ code is a macro found at the bottom of the file:
		</p>

		<pre class="prettyprint linenums">
NORI_REGISTER_CLASS(Diffuse, "diffuse");</pre>

		<p>
			Certain objects can be nested hierarchically. For
			example, the following XML snippet creates a mesh that loads its
			contents from an external OBJ file and assigns a red diffuse BRDF
			to it.
		</p>

		<pre class="prettyprint linenums lang-xml">
&lt;mesh type="obj"&gt;
    &lt;string type="filename" value="bunny.obj"/&gt;

    &lt;bsdf type="diffuse"&gt;
        &lt;color name="albedo" value="0.5, 0, 0"/&gt;
    &lt;/bsdf&gt;
&lt;/mesh&gt;
</pre>
		<p>
			Implementation-wise, this kind of nesting will cause a method named
			<tt>addChild()</tt> to be invoked within the parent object. In this
			specific example, this means that <tt>Mesh::addChild()</tt> is
			called, which roughly looks as follows:
<pre class="prettyprint linenums">
void Mesh::addChild(NoriObject *obj) {
    switch (obj->getClassType()) {
        case EBSDF:
            if (m_bsdf)
                throw NoriException(
                    "Mesh: multiple BSDFs are not allowed!");
            /// Store pointer to BSDF in local instance
            m_bsdf = static_cast&lt;BSDF *&gt;(obj);
            break;
    // ..(omitted)..
}
</pre>
			This function verifies that the nested object is a BSDF, and that no BSDF was specified
			before; otherwise, it throws an exception of type <tt>NoriException</tt>.
		</p>
		<p>
			The following different types of properties can currently be passed to 
			objects within the XML description language:
		</p>
		<div class="row">
			<div class="col-md-6">
				<pre class="prettyprint linenums">
&lt;!-- Basic parameter types --&gt;
&lt;string name="property name" value="arbitrary string"/&gt;
&lt;boolean name="property name" value="true/false"/&gt;
&lt;float name="property name" value="float value"/&gt;
&lt;integer name="property name" value="integer value"/&gt;
&lt;vector name="property name" value="x, y, z"/&gt;
&lt;point name="property name" value="x, y, z"/&gt;
&lt;color name="property name" value="r, g, b"/&gt;</pre>
			</div>
			<div class="col-md-6">
				<pre class="prettyprint linenums">
&lt;!-- Linear transformations use a different syntax --&gt;
&lt;transform name="property name"&gt;
    &lt;!-- Any sequence of the following operations: --&gt;
    &lt;translate value="x, y, z"/&gt;
    &lt;scale value="x, y, z"/&gt;
    &lt;rotate axis="x, y, z" angle="deg."/&gt;
    &lt;!-- Useful for cameras and spot lights: --&gt;
    &lt;lookat origin="x,y,z" target="x,y,z" up="x,y,z"/&gt;
&lt;/transform&gt;</pre>
			</div>
		</div>

		<p>
			The top-level element of any scene file is usually a
			<tt>&lt;scene&gt;</tt> tag, but this is not always the
			case.
			For instance, some of the programming assignments will ask you to
			run statistical tests on BRDF models or rendering algorithms, and
			these tests are also specified using the XML scene description
			language, like so:
		</p>
		<pre class="prettyprint linenums lang-xml">
&lt;?xml version="1.0"?&gt;

&lt;test type="chi2test"&gt;
    &lt;!-- Run a χ<sup>2</sup> test on the microfacet BRDF model (@ 0.01 significance level) --&gt;
    &lt;float name="significanceLevel" value="0.01"/&gt;

    &lt;bsdf type="microfacet"&gt;
        &lt;float name="alpha" value="0.1"/&gt;
    &lt;/bsdf&gt;
&lt;/test&gt;</pre>
		
		<h3>Creating your first Nori class</h3>
		<p>
			In Nori, rendering algorithms are referred to as <em>integrators</em>
			because they generally solve a numerical integration problem. The remainder
			of this section explains how to create your first (dummy) integrator which
			visualizes the surface normals of objects.
		</p>
		<p>
			We begin by creating a new Nori object subclass in <tt>src/normals.cpp</tt> with
			the following content:
		</p>
		<pre class="prettyprint linenums lang-cpp">
#include &lt;nori/integrator.h&gt;

NORI_NAMESPACE_BEGIN

class NormalIntegrator : public Integrator {
public:
    NormalIntegrator(const PropertyList &amp;props) {
        m_myProperty = props.getString("myProperty");
        std::cout &lt;&lt; "Parameter value was : " &lt;&lt; m_myProperty &lt;&lt; std::endl;
    }

    /// Compute the radiance value for a given ray. Just return green here
    Color3f Li(const Scene *scene, Sampler *sampler, const Ray3f &amp;ray) const {
        return Color3f(0, 1, 0);
    }

    /// Return a human-readable description for debugging purposes
    std::string toString() const {
        return tfm::format(
            "NormalIntegrator[\n"
            "  myProperty = \"%s\"\n"
            "]",
            m_myProperty
        );
    }
protected:
    std::string m_myProperty;
};

NORI_REGISTER_CLASS(NormalIntegrator, "normals");
NORI_NAMESPACE_END</pre>
		To try out this integrator, we first need to add it to the CMake build system:
		for this, open <tt>CMakeLists.txt</tt> and look for the command
		<pre class="prettyprint linenums lang-bash">add_executable(nori,
  # Header files
  include/nori/bbox.h
  ...

  # Source code files
  src/bitmap.cpp
  ...
)</pre>
		<p>
		Add the line <tt>src/normals.cpp</tt> at the end of the source file
		list and recompile. If everything goes well, CMake will create an
		executable named <tt>nori</tt> (or <tt>nori.exe</tt> on Windows) which
		you can call on the command line.
		</p>
		<p>
		Finally, create a small test scene with the following content and save it as <tt>test.xml</tt>:
		</p>
		<pre class="prettyprint linenums lang-xml">
&lt;?xml version="1.0"?&gt;

&lt;scene&gt;
    &lt;integrator type="normals"&gt;
        &lt;string name="myProperty" value="Hello!"/&gt;
    &lt;/integrator&gt;

    &lt;camera type="perspective"/&gt;
&lt;/scene&gt;
</pre>
<p>
		This file instantiates our integrator and creates the default camera
		setup. Running <tt>nori</tt> with this scene causes two things to
		happen:
		</p>
</div>
</div>
<div class="row">
<div class="col-md-6">
First, some text output should be visible on the console:
<pre class="prettyprint lang-bash">
$ ./nori test.xml

Property value was : Hello!

Configuration: Scene[
  integrator = NormalIntegrator[
    myProperty = "Hello!"
  ],
  sampler = Independent[sampleCount=1]
  camera = PerspectiveCamera[
    cameraToWorld = [1, 0, 0, 0;
                     0, 1, 0, 0;
                     0, 0, 1, 0;
                     0, 0, 0, 1],
    outputSize = [1280, 720],
    fov = 30.000000,
    clip = [0.000100, 10000.000000],
    rfilter = GaussianFilter[radius=2.000000, stddev=0.500000]

  ],
  medium = null,
  envEmitter = null,
  meshes = {
  }
]

Rendering .. done. (took 93.0ms)
Writing a 1280x720 OpenEXR file to "test.exr"
</pre>
The Nori executable echoed the property value we provided, and 
it printed a brief human-readable summary of the scene.
The rendered scene is saved as an OpenEXR file named <tt>test.exr</tt>.
</div>
<div class="col-md-6">
	<div class="thumbnail">
		<a class="fancybox" href="images/green.png"><img src="images/green.png"/></a>
		<div class="caption">
			Secondly, a solid green window pops up. This is the image we just
			rendered! The slider at the bottom can be used to change
			the camera exposure value.
		</div>
	</div>
</div>
</div>
<div class="row">
	<div class="col-md-12">
		<h4>Visualizing OpenEXR files</h4>
		<p>
		A word of caution: various tools for visualizing OpenEXR images exist,
		but not all really do what one would expect. Adobe Photoshop and the <a
	  href="https://bitbucket.org/edgarv/hdritools/downloads">HDRITools</a> by
  Edgar Velázquez-Armendáriz work correctly, but <tt>Preview.app</tt> on Mac OS
  for instance tonemaps these files in an awkward and unclear way.
	  </p>

	  <p>
		If in doubt, you can also use Nori as an OpenEXR viewer: simply run it with an EXR file as parameter, like so:
		</p>
<pre class="prettyprint lang-bash">
$ ./nori test.exr
</pre>
		<h4>Tracing rays</h4>
		<p>
		Let's now build a more interesting integrator which traces some rays against the scene geometry. Change the file <tt>normals.cpp</tt> as shown on the left side. Invoke <tt>nori</tt> on the file <tt>scenes/pa1/bunny.xml</tt>, and you should get the image on the right. Please submit the resulting EXR file with the first programming assignment solutions to receive credit for making it all the way through the tutorial.
		</p>
</div>
</div>
<div class="row">
<div class="col-md-6">
<pre class="prettyprint lang-cpp">
#include &lt;nori/integrator.h&gt;
#include &lt;nori/scene.h&gt;

NORI_NAMESPACE_BEGIN

class NormalIntegrator : public Integrator {
public:
    NormalIntegrator(const PropertyList &amp;props) {
        /* No parameters this time */
    }

    Color3f Li(const Scene *scene, Sampler *sampler, const Ray3f &amp;ray) const {
        /* Find the surface that is visible in the requested direction */
        Intersection its;
        if (!scene-&gt;rayIntersect(ray, its))
            return Color3f(0.0f);

        /* Return the component-wise absolute
           value of the shading normal as a color */
        Normal3f n = its.shFrame.n.cwiseAbs();
        return Color3f(n.x(), n.y(), n.z());
    }

    std::string toString() const {
        return "NormalIntegrator[]";
    }
};

NORI_REGISTER_CLASS(NormalIntegrator, "normals");
NORI_NAMESPACE_END
</pre>
</div>
<div class="col-md-6">
	<div class="thumbnail">
		<a class="fancybox" href="images/normals.png"><img src="images/normals.png"/></a>
		<div class="caption">
			A shading normal rendering of the Bunny scene
		</div>
	</div>
</div>
</div>
</div>
