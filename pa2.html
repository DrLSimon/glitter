<div style="margin-top:-20px; text-align:justify">
	<h3>Preliminaries</h3>
	<p>
    In this exercise you will implement ray / object intersection
    routines for several objects: sphere, cylinder, CSG and a few more.
	</p>

	<p>
		This exercise is split into several parts; in each case, you will be
		asked to implement a ray / object intersection. Each implementation
    shall be placed in its own class derived from the abstract class <code>Shape</code>.
    In order to be complete, the derived class must implement the function
    <code>Shape::rayIntersect</code> (and may implement <code>Shape::getBoundingBox</code>).
    In addition, do not forget to register the class in the <code>NoriObject</code> 
    <em>factory</em>. To do so, you simply need to call the <code>NORI_REGISTER_CLASS</code> macro.
    Eventually, you will have to add the new <tt>cpp</tt> source files in the <tt>CMakeLists.txt</tt>
    file.
    You can start by reproducing the organization of the <code>Plane</code> class available
    in the <tt>src/plane.cpp</tt> file.
	</p>

	<h3>Part 1: Sphere, Box, Instancing, Cylinder, Cone <em>(70 points)</em></h3>
	<p>
    For each of the following primitives, implement the missing class in 
    a new file (<em>e.g.</em><code>class Sphere</code> in file  
    <tt>src/sphere.cpp</tt>):
	</p>
	
  <ul>
		<li>
			<h4><code>class Sphere</code>  <em> (20 Points)</em></h4>
      <p>
        Here you should implement the intersection between a ray and an unit sphere.
        A part from the implementation of <code>Sphere::rayIntersect</code> the rest 
        of the class can be taken from <code>class Plane</code>.
        You should save computational power by avoiding as many call to
        <code>sqrt</code> as possible. To do so, you need to implement early
        rejects (for instance in case the ray is to far from the sphere
        center).
      </p>
		</li>
		<li>
			<h4><code>class Box</code>  <em> (30 Points)</em></h4>
      <p>
        Here you should implement the intersection between a ray and an <em>axis-aligned</em> unit box.
        You should implement the <em>one hit to rule them all</em> strategy.
        It consists in computing the intersection with a single side plane of the box.
        Then all other intersections must be computed efficiently. Last, testing whether
        the ray truly intersect the box can be done by simple distance comparisons.
      </p>
		</li>
		<li>
			<h4><code>class Instance</code>  <em> (20 Points)</em></h4>
      <p>
        Here you should implement the intersection between a ray and an <em>instance</em> of any shape.
        The new class should be called <code>Instance</code> and should encapsulate
        a single <code>Shape</code> along with a <code>Transform</code>.
      </p>
		</li>
  </ul>

	<h3>Part 2: Validation <em>(30 points)</em></h3>
	<p>
		Pass all \(\chi^2\) tests of the above intersection and include screen shots in your report.
	</p>

	<h4> What to submit </h4>
	<p>
		<ul>
			<li> A correct implementation of all intersection problems. </li> 
			<li> Screenshots of all test scenes.
      <li> time comparisons between shape primitives and their triangulated counterpart.
			</li>
		</ul>
	</p>

<h3> Hacker Points: Iterated Function Systems <em>(20 points)</em></h3>

	<div class="alert alert-info" role="alert"><b>Disclaimer</b>: Hacker points are “underpriced” bonus points 
	for the daring few. Sometimes you might be required to implement something that was not taught in class and 
	you might have to do some research and creative thinking. Hacker Points are awarded only to students who 
	implemented all of the remaining assignment. In addition Hacker Points are either fully awarded or not awarded at all.
	</div>
	<p> 
		The goal of this exercise is to implement ray tracing for Iterated Function Systems. The IFS 
    shall be specified in XML as a node containing a collection of affine transforms
    composing the Hutchinson operator. You may try your implementation on classical examples
    such as the <a src='https://en.wikipedia.org/wiki/Menger_sponge'>Menger sponge</a>.
	</p>
</div>
