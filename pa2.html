<div style="margin-top:-20px; text-align:justify">
  <h2>Goal</h2>
  <p>
  In this assignment, you will have two goals:
  <ul>
    <li>Learn how to use uniform variables in GLSL programs</li>
    <li>Going to 3D by using the standart transform pipeline from <em>object coordinates</em> to 
      <em>normalized device coordinates (NDC)</em></li>
  </ul>
  </p>
  <p>
  As usual, begin by importing the latest base code updates into your
  repository by running
  </p>
  <pre class="prettyprint lang-bash">
git pull https://github.com/DrLSimon/glitter
  </pre>

  <h2>Useful files</h2>
  <p>For this tutorial, you will find the following files useful:
  <ul>
    <li><tt>src/glApi.hpp</tt></li>
    <li><tt>src/glApi.cpp</tt></li>
    <li><tt>examples/PA2Application.hpp</tt></li>
    <li><tt>examples/PA2Application.cpp</tt></li>
    <li><tt>shaders/simple3d.v.glsl</tt></li>
    <li><tt>shaders/simple3d.f.glsl</tt></li>
  </ul>
  </p>

  <div class="row col-md-12">
    <div class="row">
      <div class="col-md-7">
        <h2>Part 1: Sending uniform values</h2>
        <p>In this part you will modify only the file <tt>src/glApi.cpp</tt></p>
        <p>Start by looking at all the files listed above to grasp a general idea of the 
        workflow. Then look more precisely at the fragment shader and notice that
        it is supposed to use a uniform variable named <em>time</em> which is
        of type <em>float</em> in order to change the green component of the fragment color.</p>

        <p>Right now, the function allowing to send values to the progam are not implemented. Implement these functions:
        <ul>
          <li><code class="cpp">void uniformDispatcher(int location, const T & value) const;</code>
            <li><code class="cpp">bool getUniformLocation(const std::string & name, int & location) const;
              </code></li>
          </li>
        </ul>
        </p>
        <h2>Part 2: Validation</h2>
        <p>
        To verify that your implementation works correctly, you can run:
        </p>
        <pre class="prettyprint lang-bash">
$ ./glitter pa2 </pre>
      </div>
      <div class="col-md-5">
        <div class="thumbnail">
          <a class="fancybox" href="images/pa2_1.gif"><img src="images/pa2_1.gif"/></a>
          <div class="caption">
            Rendering after first part completion: a rectangle with time changing colors.
          </div>
        </div>
      </div>
    </div>
  </div>

  <h2>Part 3: Going to 3D</h2>

  Look at the code of <code class="c++">PA2Application::makeACube</code> and notice that the VAO
  corresponds truely to a simple square. Besides the vertex shader <tt>shaders/simple3d.v.glsl</tt>
  is reading a 2d input attribute per vertex <code class="glsl">in vec2 vertexPosition</code>. 
  Modify both the shader and the C++ function to display a real 3d cube.

  <h2>Part 4: Instancing</h2>
  As you may have noticed, in the current version of the vertex shader, all 3d
  positions are defined in the <em>Normalized Devise Coordinates</em> system
  (NDC). In order to instanciate an object at a given location and with a given
  pose, we must differentiate between the object coordinates and the NDC ones.
  Such a transform is often called MVP for <em>Model View Projection</em>
  tranform. In this part you must define a uniform GLSL matrix (or several if
  you are willing to decompose the transform).  Modify the vertex shader to
  include the needed MVP matrix and complete the code of <code
  class="c++">PA2Application::renderFrame</code> so that the value of the
  uniform matrix variable is set-up correctly. 
</div>


